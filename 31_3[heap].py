# 백준 2751 [수 정렬하기 2]

# 목표: 힙 정렬 구현하기

# --------------------------------------------------------------------------------------------------------
# '힙'?
#  => 부모의 값이 자식의 값보다 항상 크다는 조건을 만족하는 '완전 이진 트리'
# --------------------------------------------------------------------------------------------------------
# '완전 이진 트리'와 '힙'의 차이?

#  => 완전 이진 트리는 부모자식간의 대소구분 X.
# 	[참고: '완전'은 부모노드에서 왼쪽 자식노드부터 추가해 모양을 유지하는 것을 의미함. '이진'은 한 부모 노드가 자식노드를 최대 2개 가질 수 있음을 의미]

#  => 힙은 부모가 자식보다 커야하지만, 자식끼리는 어느쪽이 크던 상관없음(= 부분순서트리)
# --------------------------------------------------------------------------------------------------------
#  힙정렬이란?
#  => 부모노드의 값이 자식노드의 값보다 항상 큼을 이용한 정렬.

#  [순서]
# 1. 배열을 힙상태로 만든다.  ※계산의 편의를 위해 인덱스0은 비워두고 1부터 시작하기도 한다.
#  (힙정렬 반복)
# 2. 힙의 부모노드를 배열의 맨 뒤로 밀고 힙의 단말에 있던(맨 뒤에 있던) 값을 루트에 넣는다.
# 3. 자식노드 2개와 비교해 더 큰 자식과 swap한다.(본인값이 가장 클 때까지 || 단말에 도달해 자식이 더 이상 없을 때 까지 반복)

# 값 받기
testcase = int(input())
list = []
for i in range(testcase):
	list.append(int(input()))

# list = [5, 2, 9, 4, 3, 7, 8, 11, 16, 12, 15, 10, 6, 0, 1] # 원소 10개인 리스트

# 1. 배열을 힙 상태로 만들기
def max_heap(a, n, end):

	while True:
		parent = n
		left = n*2+1
		right = n*2+2

		biggerChild = right if right < len(a) and a[left] <= a[right] else left
		if a[parent] >= a[biggerChild] or biggerChild > end:
			break
		else:
			# print('swap: '+ str(a[biggerChild])+', ' +str(a[parent]))
			a[biggerChild], a[parent] = a[parent], a[biggerChild]
			if biggerChild < len(list)//2: #a[biggerChild]에 자식노드가 있다면
				max_heap(a, biggerChild, end)	#swap으로 힙구조가 깨지지 않았는지 점검 (재귀)

l = len(list)

# 부모 노드의 인덱스만 넣어야 함(자식없으면 안됨)
# 완전 이진 트리에서 부모의 개수(단말이 아닌 노드의 개수)는 len // 2(나머지 버림)
for i in range(l//2-1, -1, -1): # 부모노드의 개수-1, 이 -1이 될 때까지, -1씩 반복
														# (부모노드의 개수, 0, -1)이렇게 하지않고 부모노드의 개수에서 -1을 해준 이유는 i를 리스트의 인덱스로 넣어야했기 때문(0부터 시작하므로 개수-1)
	max_heap(list, i, l-1)
	# print(list)

for i in range(l-1, 0, -1):
	# print(str(a[0]),str(a[i]))
# 2. 힙의 루트를 배열의 맨 뒤로 밀고 힙의 단말에 있던(맨 뒤에 있던) 값을 루트에 넣는다.
	list[0], list[i] = list[i], list[0]
# 3. 자식노드 2개와 비교해 더 큰 자식과 swap한다.(본인값이 가장 클 때까지 || 단말에 도달해 자식이 더 이상 없을 때 까지 반복)
	max_heap(list, 0, i-1)
	# print(list)
if list[0] > list[1]:   #최초 배열에서 최소값이 맨 마지막 인덱스에 있으면 최소값이 맨 앞으로 오지 않는 문제 해결
	list[0], list[1] = list[1], list[0]
	# print(list)
for i in range(len(list)):
	print(list[i])


